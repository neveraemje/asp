{
  "version": 3,
  "sources": ["../../../../node_modules/markdown-it-container/index.js", "../../../../node_modules/vuepress-plugin-tabs/dist/vuepress-plugin-tabs.esm.js"],
  "sourcesContent": ["// Process block-level custom containers\n//\n'use strict';\n\n\nmodule.exports = function container_plugin(md, name, options) {\n\n  // Second param may be useful if you decide\n  // to increase minimal allowed marker length\n  function validateDefault(params/*, markup*/) {\n    return params.trim().split(' ', 2)[0] === name;\n  }\n\n  function renderDefault(tokens, idx, _options, env, slf) {\n\n    // add a class to the opening tag\n    if (tokens[idx].nesting === 1) {\n      tokens[idx].attrJoin('class', name);\n    }\n\n    return slf.renderToken(tokens, idx, _options, env, slf);\n  }\n\n  options = options || {};\n\n  var min_markers = 3,\n      marker_str  = options.marker || ':',\n      marker_char = marker_str.charCodeAt(0),\n      marker_len  = marker_str.length,\n      validate    = options.validate || validateDefault,\n      render      = options.render || renderDefault;\n\n  function container(state, startLine, endLine, silent) {\n    var pos, nextLine, marker_count, markup, params, token,\n        old_parent, old_line_max,\n        auto_closed = false,\n        start = state.bMarks[startLine] + state.tShift[startLine],\n        max = state.eMarks[startLine];\n\n    // Check out the first character quickly,\n    // this should filter out most of non-containers\n    //\n    if (marker_char !== state.src.charCodeAt(start)) { return false; }\n\n    // Check out the rest of the marker string\n    //\n    for (pos = start + 1; pos <= max; pos++) {\n      if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n        break;\n      }\n    }\n\n    marker_count = Math.floor((pos - start) / marker_len);\n    if (marker_count < min_markers) { return false; }\n    pos -= (pos - start) % marker_len;\n\n    markup = state.src.slice(start, pos);\n    params = state.src.slice(pos, max);\n    if (!validate(params, markup)) { return false; }\n\n    // Since start is found, we can report success here in validation mode\n    //\n    if (silent) { return true; }\n\n    // Search for the end of the block\n    //\n    nextLine = startLine;\n\n    for (;;) {\n      nextLine++;\n      if (nextLine >= endLine) {\n        // unclosed block should be autoclosed by end of document.\n        // also block seems to be autoclosed by end of parent\n        break;\n      }\n\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent) {\n        // non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        break;\n      }\n\n      if (marker_char !== state.src.charCodeAt(start)) { continue; }\n\n      if (state.sCount[nextLine] - state.blkIndent >= 4) {\n        // closing fence should be indented less than 4 spaces\n        continue;\n      }\n\n      for (pos = start + 1; pos <= max; pos++) {\n        if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n          break;\n        }\n      }\n\n      // closing code fence must be at least as long as the opening one\n      if (Math.floor((pos - start) / marker_len) < marker_count) { continue; }\n\n      // make sure tail has spaces only\n      pos -= (pos - start) % marker_len;\n      pos = state.skipSpaces(pos);\n\n      if (pos < max) { continue; }\n\n      // found!\n      auto_closed = true;\n      break;\n    }\n\n    old_parent = state.parentType;\n    old_line_max = state.lineMax;\n    state.parentType = 'container';\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine;\n\n    token        = state.push('container_' + name + '_open', 'div', 1);\n    token.markup = markup;\n    token.block  = true;\n    token.info   = params;\n    token.map    = [ startLine, nextLine ];\n\n    state.md.block.tokenize(state, startLine + 1, nextLine);\n\n    token        = state.push('container_' + name + '_close', 'div', -1);\n    token.markup = state.src.slice(start, pos);\n    token.block  = true;\n\n    state.parentType = old_parent;\n    state.lineMax = old_line_max;\n    state.line = nextLine + (auto_closed ? 1 : 0);\n\n    return true;\n  }\n\n  md.block.ruler.before('fence', 'container_' + name, container, {\n    alt: [ 'paragraph', 'reference', 'blockquote', 'list' ]\n  });\n  md.renderer.rules['container_' + name + '_open'] = render;\n  md.renderer.rules['container_' + name + '_close'] = render;\n};\n", "var slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n// Map to keep track of used ids\nvar tabIds = new Map();\n\nfunction dedupeId(id) {\n  var normalizedId = String(id).toLowerCase().replace(' ', '-');\n  var currentValue = !tabIds.has(normalizedId) ? 1 : tabIds.get(normalizedId) + 1;\n  tabIds.set(normalizedId, currentValue);\n\n  return normalizedId + '-' + currentValue;\n}\n\nfunction tabAttributes(val) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var attributes = val\n  // sanitize input\n  .trim().slice(\"tab\".length).trim()\n  // parse into array\n  .split(/ +(?=(?:(?:[^\"]*\"){2})*[^\"]*$)/g)\n  // normalize name attribute\n  .map(function (attr) {\n    if (!attr.includes(\"=\")) {\n      if (!attr.startsWith('\"')) {\n        attr = '\"' + attr;\n      }\n\n      if (!attr.endsWith('\"')) {\n        attr = attr + '\"';\n      }\n\n      return 'name=' + attr;\n    }\n\n    return attr;\n  });\n\n  if (options.dedupeIds) {\n    var idIndex = attributes.findIndex(function (attr) {\n      return attr.startsWith('id=');\n    });\n    var nameIndex = attributes.findIndex(function (attr) {\n      return attr.startsWith('name=');\n    });\n\n    if (idIndex !== -1) {\n      var id = attributes[idIndex];\n\n      var _id$split = id.split('='),\n          _id$split2 = slicedToArray(_id$split, 2),\n          idValue = _id$split2[1];\n\n      attributes[idIndex] = 'id=\"' + dedupeId(idValue.substring(1, idValue.length - 1)) + '\"';\n    } else {\n      var name = attributes[nameIndex];\n\n      var _name$split = name.split('='),\n          _name$split2 = slicedToArray(_name$split, 2),\n          nameValue = _name$split2[1];\n\n      attributes.unshift('id=\"' + dedupeId(nameValue.substring(1, nameValue.length - 1)) + '\"');\n    }\n  }\n\n  return attributes.join(\" \");\n}\n\nfunction tabsAttributes(val) {\n  return val\n  // sanitize input\n  .trim().slice(\"tabs\".length).trim();\n}\n\nfunction defaultTabsAttributes(attributes) {\n  var attributesString = [];\n  if (!attributes || Object.keys(attributes).length === 0) {\n    return '';\n  }\n\n  for (var key in attributes) {\n    var substring = ':' + key + '=\\'' + JSON.stringify(attributes[key]) + '\\'';\n    attributesString.push(substring);\n  }\n\n  return attributesString.join(' ');\n}\n\nvar container = require('markdown-it-container');\n\nvar tabs = (function (md, options) {\n  md.use(container, 'tabs', {\n    render: function render(tokens, idx) {\n      var token = tokens[idx];\n      var defaultAttributes = defaultTabsAttributes(options.tabsAttributes);\n      var attributes = tabsAttributes(token.info);\n\n      if (token.nesting === 1) {\n        return '<tabs ' + defaultAttributes + ' ' + attributes + '>\\n';\n      } else {\n        return '</tabs>\\n';\n      }\n    }\n  });\n});\n\nvar container$1 = require('markdown-it-container');\n\nvar tab = (function (md, options) {\n  md.use(container$1, 'tab', {\n    render: function render(tokens, idx) {\n      var token = tokens[idx];\n      var attributes = tabAttributes(token.info, options);\n\n      if (token.nesting === 1) {\n        return '<tab ' + attributes + '>\\n';\n      } else {\n        return '</tab>\\n';\n      }\n    }\n  });\n});\n\nmodule.exports = function (opts) {\n  var defaultOptions = {\n    dedupeIds: false\n  };\n\n  var options = Object.assign({}, defaultOptions, opts);\n\n  return {\n    enhanceAppFiles: [{\n      name: 'register-vue-tabs-component',\n      content: 'import Tabs from \\'vue-tabs-component\\';export default ({ Vue }) => Vue.use(Tabs)'\n    }],\n    extendMarkdown: function extendMarkdown(md) {\n      tabs(md, options);\n      tab(md, options);\n    }\n  };\n};\n"],
  "mappings": "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",
  "names": []
}
